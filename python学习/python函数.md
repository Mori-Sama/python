# 关于名称空间

**名称空间的嵌套关系是以定义为准的，与调用位置无关，即在调用时，名称空间的寻找顺序是以定义的时候为标准**

**名称空间的嵌套关系决定了名字的查找顺序**
**而名称空间的嵌套关系是以函数定义阶段为准的**
**即函数的嵌套关系与名字的查找顺序是在定义阶段就已经确定好的**

~~~python
x = 111
def func():
	print(x)
def foo():
    x = 222
    func()
foo() >>> 111

# 可以理解为，当func()时，函数是返回自己所在的空间查找值，func()只是表示调用，与其调用的名称空间无关

x = 111

def func():
	print(x)

x = 333
def foo():
    x = 222
    func()

foo() >>> 333
~~~

## 三大名称空间

~~~python
# 全局名称空间（当前py文件）
# 局部名称空间（builtins.py）
# 内置名称空间（函数执行）

# 加载顺序
内置 --> 全局 --> 局部

# 两个作用域
# 全局作用域，局部作用域
~~~

## globals(),locals()

~~~python
# globals() 返回字典，字典封装的是全局作用域的所有内容
# locals() 返回字典，字典封装的是当前作用域的所有内容

# global关键字，在局部声明一个全局变量
# nonlocal关键字，它不能操作全局变量，只能用于内层函数对外层函数变量的修改
~~~



# 关于闭包

**闭包函数=名称空间与作用域+函数嵌套+函数对象**

**核心：名字的查找关系是以函数定义阶段为标准的**

**1.该函数时内嵌函数**
**2.该函数包含对外侧函数作用域名字的引用**
**总结：内层函数对外层函数的引用**
**作用：保证数据安全（闭包部分的数据无法被全局访问到）**

~~~python
def func():
    x = []
    def foo(n):
        x.append(n)
        return sum(x)/len(x)
    return foo
print(func()())
x.append(1) 报错

# 内层函数对外层函数非全局变量的使用就会形成闭包
# 被引用的非全局变量会与内层函数产生一个绑定关系
# 此时的x叫做自由变量，自由变量不会在内存中消失
~~~

# 装饰器

**装饰器就是在不修改被装饰对象源代码以及调用方式的前提下为被装饰对象添加新功能**

**开放封闭原则：对拓展功能开放，对修改源码封闭**

**如果有多个装饰器装饰同一个函数时，装饰器的加载顺序时从下至上，运行顺序是自上而下**

~~~python
from functools import wraps # 把原函数的属性赋给装饰器
def wrapper(f): # 这个f就是被装饰的函数
    # @wraps(f) 即把原函数的__xxx__的方法装饰给inner
    def inner(*args,**kwargs): # 聚合参数
        '''被装饰函数执行之前，执行的代码'''
        ret = f(*args,**kwargs) # 参数在这里打散
        '''被装饰函数执行之后，执行的代码'''
        return ret # 这是被装饰函数的返回值
    
    return inner
'''
工作原理：
func = wrapper(func)
func()
'''
@wrapper # 语法糖：即把工作原理的代码合在一起
def func():
    print('被装饰的函数')
~~~

# 带参数的装饰器

函数需要什么参数由函数内部决定

~~~python
def func(x): # x下面装饰器内需要用到的参数
    def wrapper(f): # f被装饰的参数
        def inner(*args,**kwargs):
            ret = f(*args,**kwargs)
            return ret
        return inner
    return wrapper

@func(x) # 函数名加括号执行，返回wrapper，并让参数x形成闭包，最后形成@wrapper
~~~

# 迭代器

**迭代是一个重复的过程，每次重复都是基于上一次的结果而继续的，单纯的重复并不是迭代**

~~~python
# 可迭代对象：内部含有__iter__方法的对象
# 迭代器对象：内部含有__iter__,__next__方法的对象
# 调用可迭代对象下的__iter__方法，可以将其转换成迭代器对象，调用其下的__next__方法取值
# 同一个迭代器只能使用一次

# for循环的工作原理
d = [1,2,3,4]
for i in d:
    print(d)
'''
1、d.__iter__()得到一个迭代器对象 / iter(d) 
2、迭代器对象.__next__()/next(迭代器对象) 拿到一个返回值，然后将该返回值赋值给i
3、循环过程2直到抛出StopIteration异常，for循环捕捉异常，然后结束
'''

# 惰性机制：next一次，取一个值
# 取值不走回头路，只能一直向下取值
~~~

# 生成器

~~~python
# 生成器的本质就是迭代器，唯一的区别就是生成器是我们自己利用python代码构建的
# 生成器函数返回的是一个迭代器,
def func(i):
    while 1:
        x =  yield i
        i += 1
        print(x)
iter1 = func(1) # 此时函数不会执行，只是返回一个迭代器对象
print(next(iter1)) # 此时函数才会运行，并且在运行完第一个yield时卡住，保持函数的挂起状态，直到下一次next才会接着运行
n = iter1.send('xxx') # send可以将参数传递给x，同时send也调用了一次next
print(n)
'''
output:
1
xxx
2
'''

# 生成器表达式,用括号()包起来的表示生成器
g = (i for i in range(50))
~~~

## yield和yield from和return

~~~python
# yield：一个next对应一个yield，yield不会结束函数
# return：函数中只存在一个return结束函数
# yield from：将后面的变量变成迭代器，然后yield

# 只要函数中含有yield关键字，他就不再是函数，而是生成器
~~~



# 关于递归

**递归分两个阶段：**
**1.回溯：一层一层的调用下去**
**2.递推：满足某种条件，结束递归调用，然后一层一层返回**
**3.递归的最大深度为1000层，可以用sys模块修改，sys.setrecursionlimit()**

**递归必须有终止条件**

# 关于导入模块/包

**本质上是将名称空间导入（copy）到当前执行导入操作的空间**

~~~python
# 导入包的时候实际上是执行了包下面的__init__.py文件，结合导入的实质，在包下面的模块，应该在本包下面的init文件中导入一次，而对于包中的包也应该如此。
# 针对from ... import * 导入方法可以用__all__ = ['能导入的名称'] 来控制能被导入的部分
~~~

**模块查找的优先级：内存（内置模块）> 硬盘（sys.path列表中的文件夹）**

**导入的模块在整个程序运行过程中一直存在于内存中，即便用del解除绑定关系，也不会被当成垃圾回收，但是要使用的话需要重新导入，此时被导入的模块是直接从内存中导入**

**绝对导入：以定义包为起点**
**相对导入：.  代表当前文件夹，..  表示上一层文件夹**

**如果涉及到跨文件夹导入：**

~~~python
# 如果创建了一个项目，里面的文件涉及到跨文件夹导入的问题
# 在运行文件里面，把项目文件的文件夹名添加进sys.path中去
import os
import sys
sys.path.append(os.path.dirname(os.path.dirname(__file__))) # os.path.dirname嵌套多少此取决于运行文件离项目主文件夹多远
~~~

## 匿名函数lambda

~~~python
x = lambda 参数:返回值
# x表示接收的返回值

# 常和map()连用
l = '1234'
l1 = list(map(lambda x:int(x),l))
~~~

## 杂项

~~~python
# return如果返回多个值，则是以元组的形式返回

# 在函数定义的时候 * 号表示聚合，函数中的万能参数 *args 接收所有的位置参数聚合成元组赋给args
# 在函数调用的时候 * 号表示打散。 ** 也表示打散，怎么聚合，怎么打散。

# **kwargs 接收所有的关键字参数，将其聚合成字典赋给kwargs

# 形参的顺序：位置参数,*args,关键字参数,仅限关键字参数,**kwargs
def func(a,b,*args,sex='male',c,**kwargs):
    pass
func(1,2,3,4,5,sex='female',name='zhao',age=18,c='xulu')

# 当函数的默认参数是可变数据类型的时候，无论调用多少次这个默认参数，用的都是同一个
def func(a, lis=[]):
    lis.append(a)
    return lis
print(func(10)) # [10]
print(func(20,[])) # [20]
print(func(100)) # [10,100]
# 
# 函数名就是一个变量，函数名() 执行函数，函数名有变量的属性
~~~













