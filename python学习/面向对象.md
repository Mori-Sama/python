# 面向对象

**对象**：容器，存储着属性（数据）和方法（功能）
**对象的目的就是将程序整合**

类体中的代码在类定义阶段就会立即执行，产生类的名称空间

~~~python
# 类下的__init__方法
# 会在调用类实例化时自动触发执行，用来为对象初始化自己独有的属性
# __init__内应该存放的是为对象初始化属性的功能，但是可以存放任意代码，在实例化的时候一同执行
# __init__函数的返回值必须为None，不要在内部加上return
~~~

对象属性的查找顺序：现在对象中查找，再去类中查找

类中存放的所有实例化对象的共有属性和方法

~~~python
class Student():
    teacher = 'zhao' # 类属性
    def __init__(self,name): # self参数表示的时实例化对象本身
    	self.name = name # 对象属性
# 注意如果要在对象中改类的属性不能用以下方法：
alex = Student('xu')
alex.teacher = 'lu' # 这种方式是给对象下面创建了一个teacher属性，(如果有则修改，如果无则创建)
# 应该用类名去调用类下的方法
Student.teacher = 'lu'
~~~

## 组合

~~~python
# 即类于类之间可以相互调用
# 一个类的对象，可以是另一个类对象的属性
~~~

# 封装

## **隐藏属性**

~~~python
# 在属性名前加__就会实现一个对外隐藏属性的效果
class Foo():
    __x = 1 # 私有的静态变量
    def __init__(self,name):
        self.__name = name
    def __func(self):
        print(self.__name)
# 这种隐藏方法实际上是一个变形，原来的名称会变成，_类名__方法或属性名，这种形式，如果要在类的外部强制访问，仍然能访问到
# 这种隐藏方法对外不对内，在类的内部调用的时候可以直接通过，__方法或属性名，访问
# 变形只会在检测类体语法的时候发生一次，以后定义的__方法或属性都不会发生变形操作
# 例如：
Foo.__y = 0
print(Foo.__y) -----> 0

# 私有内容不能被子类使用
~~~

## **property装饰器**

~~~python
# 将绑定给对象的方法伪装成一个数据属性
class People:
    def __init__(self,name,weight,height):
        self.name = name
        self.weight = weight
        self.height = height
    @property
    def bmi(self):
        bmi = self.weight/(self.height**2)
        return bmi

zhao = People('zhao',55,1.73)
print(zhao.bmi) # 可以直接调用不用加括号，封装的函数不能有参数
~~~

## 其他用法

~~~python
# property方法中有个四个参数
# 第一个参数是方法名，调用 对象.属性 时自动触发执行方法
# 第二个参数是方法名，调用 对象.属性 ＝ XXX 时自动触发执行方法
# 第三个参数是方法名，调用 del 对象.属性 时自动触发执行方法
# 第四个参数是字符串，调用 对象.属性.__doc__ ，此参数是该属性的描述信息

class Foo(object):
    def get_bar(self):
        print("getter...")
        return 'laowang'

    def set_bar(self, value): 
        """必须两个参数"""
        print("setter...")
        return 'set value' + value

    def del_bar(self):
        print("deleter...")
        return 'laowang'

    BAR = property(get_bar, set_bar, del_bar, "description...")

obj = Foo()

obj.BAR  # 自动调用第一个参数中定义的方法：get_bar
obj.BAR = "alex"  # 自动调用第二个参数中定义的方法：set_bar方法，并将“alex”当作参数传入
desc = Foo.BAR.__doc__  # 自动获取第四个参数中设置的值：description...
print(desc)
del obj.BAR  # 自动调用第三个参数中定义的方法：del_bar方法

~~~

~~~python
class Goods:
    """ 
    	python3中默认继承object类
        以python2、3执行此程序的结果不同，因为只有在python3中才有			    			@xxx.setter  @xxx.deleter
    """
    @property
    def price(self):
        print('@property')

    @price.setter
    def price(self, value):
        print('@price.setter')

    @price.deleter
    def price(self):
        print('@price.deleter')

obj = Goods()
obj.price          # 自动执行 @property 修饰的 price 方法，并获取方法的返回值
obj.price = 123    # 自动执行 @price.setter 修饰的 price 方法，并将  123 赋值给方法的参数
del obj.price      # 自动执行 @price.deleter 修饰的 price 方法
# 这种方法要求所有被装饰的函数名称相同
# 对象名.__dict__ 会把实例化对象的属性作为字典返回
~~~

### 其他装饰器

~~~python
class People(object):
    def __init__(self,name,age,pet):
        self.name = name
        self.age = age
        self.pet = pet
        
    @classmethod # 将下面函数绑定给类，一般是给类提供一个新的生成对象的方式
    def func(cls): # 约定俗称的参数cls表示类，自动传入这个参数
        return '你是傻逼',cls
    
    @staticmethod # 将下列函数绑定为静态方法
    def func1(name):
        print(f'{name}') # 这就相当于一个普通函数
~~~

# 继承

新式类：继承了object类的子类，以及该子类的子类......
经典类：没有继承object类的子类，以及该子类的子类......
python3中所有的类默认继承object，所以python3中没有经典类
python中存在多继承，即一个类可以继承多个父类

**单继承的查找：先从子类找再从父类找，严格按照这个规则**

**多继承的查找：遵循C3算法，可用 类名.mro() 查看查找顺序**

~~~python
class School:
    def __init__(self,zone,sname,level):
        self.zone = zone
        self.name = sname
        self.level = level

class Student(School):
    def __init__(self, zone, sname, level, name):
        super(Student, self).__init__(zone, sname, level) # 这相当于调用被继承类的init方法，等同于School.__init__(self, zone, sname, level)，super()查询顺序是，参照属性发起者的mro
        self.name = name
        
# super可以调父类的方法、属性
~~~

## C3算法

~~~python
A(O) = [AO]
B(A) = [BAO]
C(A) = [CAO]
D(B) = [DBAO]
E(C) = [ECAO]
F(D,E) = [F] + [DBAO] + [ECAO]
	 F = [DBAO] + [ECAO] # 从左到右第一个类没有在后面出现，就提出来
    FD = [BAO] + [ECAO]
    FDB = [AO] + [ECAO]
    FDBE = [AO] + [CAO]
    FDBEC = [AO] + [AO]
    FDBECA = [O] + [O]
    FDBECAO
~~~



## 多继承的mixin规范

mixin规范作用：在多继承背景下尽可能的提升多继承代码的可读性
mixin类必须表示一类功能，而不是某个物品，python对于mixin类的命名方式一般以Mixin,able,ible结尾
mixin类不依赖于子类实现，它表示单独的功能

~~~python
class A:
    pass
class BMixin:
    pass
class C(BMixin,A):
    pass
class D(BMixin,A):
    pass
class E(A):
    pass
# C，D，E都属于A的子类，但是CD不同于E，CD中有着相同的特殊功能，在这里，我们专门创建一个mixin类叫BMixin用来存放CD共有的一种特殊方法，并将其继承给CD，我们约定，BMixin类实际代表的是方法，而不是CD的父类（约定上）
~~~

**注意：属性的查找顺序是按照发起者的mro来查找，而不是肉眼看见的继承关系**

~~~python
class A:
    def test(self):
        print('A')
        super().test()

class B:
    def test(self):
        print('B')

class C(A,B):
    pass

obj = C()
obj.test()---->A,B
# 虽然AB之间并没有继承关系，但是A中的super方法仍然会去B中查找，因为调用的发起者是C所以查找顺序是按照C的mro来实现的，A的下一个是B，所以会去B中查找
~~~

# 抽象类

~~~python
# 是一个开发规范
# 用来实现归一化设计

# 设计一个父类，里面规定了子类必须实现的方法
class Uniform(object):
    def get(self):
        raise NotImplementedError('请在子类中实现get方法')

# 实现抽象类的另一种方式
# 约束力强，但是依赖abc模块
from abc import ABCMeta,abstractmethod
class Uniform(metaclass=ABCMeta):
    @abstractmethod # 装饰要在子类中实现的方法，如果子类中没有，那么子类将无法实例化
    def get(self):
        pass
~~~



# 多态

同一事物的多种形态，多态是一种思想
多态性指的是可以在不考虑对象具体类型的情况下直接使用对象

~~~python
import abc
class Animal(metaclass=abc.ABCMeta):
    @abc.abstractmethod # 用父类约束子类，被这个装饰器装饰的方法必须在子类中出现，否则继承了Animal的子类将不能完成实例化
    def say(self):
        pass

class People(Animal):
    def __init__(self,name):
        self.name = name

x = People('x') # 报错
~~~



**鸭子类型**
“如果你走路像鸭子，叫声像鸭子，长得像鸭子，那你就是鸭子”

# 反射

在程序运行的过程中动态的获取程序信息以及动态的调用对象的功能称为反射机制

~~~python
# 四个内置函数:通过字符串操作属性值

# hasattr()用于判断对象是否包含对应的属性
hasattr(object, name) # object对象，name字符串的属性名
# 返回值为bool值

# getattr()用于返回一个对象的属性值
getattr(object, name, default) # default设置默认返回值，如果没有这个参数，在没有对应属性时，将触发AttributeError
>>>class A(object):
...     bar = 1
... 
>>> a = A()
>>> getattr(a, 'bar')        # 获取属性 bar 值
1
>>> getattr(a, 'bar2')       # 属性 bar2 不存在，触发异常
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'A' object has no attribute 'bar2'
>>> getattr(a, 'bar2', 3)    # 属性 bar2 不存在，但设置了默认值
3
# 反射当前py文件内的内容
getattr(sys.modules['__main__'], string)


# setattr()用于设置属性值，该属性值不一定存在，不存在则创建，存在则修改
setattr(object, name, value) # value属性值

# delattr()用于删除属性值
delattr(object, name) # name必须是object的属性
delattr(x, 'foobar') 相等于 del x.foobar
~~~

# 内置方法

会在某些特殊情况下自动触发

~~~python

# __str__:在打印对象时会自动触发，然后将返回值（必须是str）当作本次打印的结果输出
# __del__:在清理对象时，会先执行该方法，程序运行完成后会回收资源，如果定义的有__del__方法，则会在清理之前执行
class A:
    def __init__(self,name):
        self.name = name
    def __str__(self):
        print('__str__方法执行')
        return f'{self.name}'
    def __del__(self):
        print('__del__方法执行')
x = A('zhao')
print(x)
del x

# __call__:让对象可以被调用
class Foo:
    def __init__(self,name):
        self.name = name
    def __call__(self):
        print('__call__方法执行')
        return '__call__方法执行完毕'
obj = Foo('zhao')
res = obj() # 执行__call__方法
print(res)

# 实例化对象.__dict__ 返回一个字典，里面是实例化对象的属性键值对

# __len__: 当 len(实例化对象) 的时候这个方法执行
~~~

# 元类

用来产生类的类
用class关键字定义的所有类以及内置的类都是由内置的元类type帮我们产生的

~~~python
class A:
    pass
print(type(int),type(A))

# class机制
# 1.类名
class_name = "People"
# 2.类的基类
class_bases = (object,)
# 3.执行类体代码拿到类的名称空间
class_dic = {} # 存放的是类的名称空间
class_body = '''
def __init__(self,name):
	self.name = name
def say(self):
	print(self.name)
'''
exec(class_body,{},class_dic)
# 4.调用元类(可自定义元类，来控制类的产生)
People = type(class_name,class_bases,class_dic)

# 自定义元类来控制类的产生
# 调用Mymeta发生的事情，即调用__call__方法
# 1.先创造一个空对象--->People，调用类内的__new__方法
# 2.调用Mymeta这个类的__init__方法，完成初始化对象的操作
# 3.返回初始化好的对象
class Mymeta(type): # 只有继承了type类的类才是元类
    def __init__(self,class_name,class_bases,class_dic):
        # 限制类名首字母必须大写
        if not class_name.istitle():
            raise NameError('类名的首字母必须大写')
    def __new__(cls,*args,**kwargs):
        # 创建Mymeta对象
        return type.__new__(cls,*args,**kwargs)
    
class People(metaclass=Mymeta): # metaclass参数指定元类
    def __init__(self,name):
        self.name = name
    def say(self):
        print(self.name)

        
# 自定义元类控制类的调用即对象的产生过程
class Mymeta(type):
    def __call__(self,*args,**kwargs):
        # 1.mymeta.__call__函数内会先调用people内的__new__
        people_obj = self.__new__(self)
        # 2.mymeta.__call__函数内会调用people内的__init__
        self.__init__(people_obj,*args,**kwargs)
        # 3.mymeta.__call__函数会返回一个初始化好的对象
        return people_obj
    
class People(metaclass=Mymeta): # metaclass参数指定元类
    def __init__(self,name):
        self.name = name
    def say(self):
        print(self.name)
    def __new__(cls,*args,**kwargs):
        return object.__new__(cls)

# 元类下的属性查找，注意父类不是元类
# 以对象作为起始点，不会去元类中查找
# 以类作为起始点，所有的父类找完后会去元类中
~~~

~~~python
# 元类定义的目的
# 1.控制类的产生
__new__,__init__
# 2.控制类的调用
__call__
~~~

## 单例模式

~~~python
# 实例化的时候，先创建一块对象的空间，有一个指针能指向类
# 这个方法为 __new__
# new方法完成后，再调用init方法

# 构造方法
class Zhao(object):
    def __new__(cls, *args, **kwargs):
        o = super().__new__(cls) # 创建一个对象空间
        return o # 把这个空间返回
    
# 单例模式
# 就是一个类从头到尾只会创建一个self的空间
class Zhao(object):
    __kongjian = None
    def __new__(cls, *args, **kwargs):
        if cls.__kongjian is None: # 如果空间不存在则创建
        	cls.__kongjian = super().__new__(cls)
        return cls.__kongjian

# 也可以利用模块导入的特性实现单例模式，原理是再python中的模块导入只能被导入一次，不会重复导入
~~~

