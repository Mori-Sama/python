# 网络编程

**ip地址：变化的，能够更方便的找到你的计算机**

**mac地址：不变的，唯一标识这台机器的**

## 交换机

~~~python
# 局域网之内的通信
# 识别mac地址，不识别ip地址
# 连接在同一个交换机上的所有机器就构成了局域网
# 交换机的通信方式为广播，可以完成广播、组播、单薄（mac地址在网卡上）
# arp协议（地址解析协议）：通过一台机器的IP地址获取到它的mac地址，用到了交换机的广播和单播
~~~

## 路由器

~~~python
# 局域网之间的通信（网关ip）
# 同一个局域网共享一个网关ip
# 交换机 ---> 网关 ---> 交换机
# 网关负责寻找网段ip
# 路由器可以理解ip
~~~

## ip地址

~~~python
# ipv4：四位点分十进制
# 范围：0.0.0.0 ~ 255.255.255.255 每一位都对应着八位二进制
# 公网地址：可申请购买
# 内网地址：保留字段
# 特殊地址：127.0.0.1 本地回环地址
# 子网掩码：用来判断两台机器在不在一个局域网内
~~~

## 端口

~~~python
# ip/mac 用来确定机器
# 端口 用来确定机器上的具体应用
# 端口范围0-65535，0-1023为系统占用端口；
~~~



## CS架构BS架构

1.cs架构：客户端client 服务端server
2.bs架构：浏览器browser 服务端server，bs架构也是cs架构的一直

### 网络通信

网络=物理链接介质+互联网通信协议

### 互联网通信协议

**OSI七层协议**
	**五层协议**：从下往上
		**应用层**：三层合并统称应用层
			应用层
			表示层
			会话层
		**传输层**：tcp/udp协议，基于端口；端口范围0-65535，0-1023为系统占用端口；
		**网络层**：IP协议，规定一组数据为一个数据包，数据包由头部+数据部分组成，头部包含的是源IP地址和目标的IP地址。划分广播域，每一个广播域都有一个接通外网的网关，网关与外界通信走的是路由协议
		**数据链路层**：Ethernet以太网协议，规定了一组数据为一个数据帧，数据帧分为头部和数据部分，头部包含源mac地址和目标mac地址，但凡接入互联网的主机必须有一块网卡，网卡上面有着全世界独一无二的地址，以太网协议工作方式是广播
		**物理层**：负责发送电信号

​	**协议**：规定数据的组织格式
​		**格式**：头部+数据部分

![以太网封装过程](C:\Users\Zhao\Desktop\图\以太网封装过程.gif)

ip地址加上mac地址，标识全世界范围内独一无二的一台计算机

## tcp协议的握手与挥手

**全双工通信**

**建立连接三次握手**：
（1）第一次握手：建立连接时，客户端A发送SYN包（SYN=j）到服务器B，并进入SYN_SEND状态，等待服务器B确认。

（2）第二次握手：服务器B收到SYN包，必须确认客户A的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器B进入SYN_RECV状态。

（3）第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK（ACK=k+1），此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。

![tcp握手](C:\Users\Zhao\Desktop\图\tcp握手.png)

**断开连接四次挥手**：由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

（1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送（报文段4）。

（2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1（报文段5）。和SYN一样，一个FIN将占用一个序号。

（3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A（报文段6）。

（4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1（报文段7）。

![tcp挥手](C:\Users\Zhao\Desktop\图\tcp挥手.jpg)

**总结**：

![tcp总](C:\Users\Zhao\Desktop\图\tcp总.jpg)

当客户端端处于TIME_WAIT状态时，意味着服务端处于高并发状态

## socket套接字

**tcp协议、非并发代码**

~~~python
'''服务端'''
import socket
# 实例化一个socket对象
sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM) # SOCK_STREAM--->流式协议--->tcp协议
# socket.socket(socket.AF_INET,socket.SOCK_DGRAM) SOCK_DGRAM--->udp协议

# 绑定本机ip(局域网)/绑定公网ip + 端口号
sock.bind(('127.0.0.1',9000))

# 监听连接
sock.listen(5) # 5指的是半连接池的大小
while 1: # 连接循环
    # 等待连接请求,返回值是一个元组 (连接对象,客户端的ip和端口)
    conn,client_addr = sock.accept()
    while 1: # 通信循环
        # 接受消息
        try: # windows系统，客户端异常终止
            msg = conn.recv(1024) # 1024表示一次最大接收1024个字节
        except Exception:break
        # if len(msg) == 0:break # linux系统下，客户端异常终止
        print(msg.decode('utf-8'))
        # 发消息
        msg1 = input('>>>')
        if msg1 == 'q':break
        conn.send(msg1.encode('utf-8'))

    # 关闭连接
    conn.close()

# 关闭服务
# sock.close()

'''客户端'''
import socket
sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM)

# 连接请求,指定连接对象的ip和端口
sock.connect(('127.0.0.1',9000))
while 1:
    # 网络传输收发的数据类型都是bytes类型
    msg1 = input('>>>')
    if msg1 == 'q':break
    if len(msg1) == 0:continue
    sock.send(msg1.encode('utf-8'))
    msg = sock.recv(1024)
    print(msg.decode('utf-8'))

# 关闭连接
sock.close()
~~~

## **udp协议**：

一个sendto，对应一个recvfrom，数据报形式

~~~python
'''服务端'''
import socket
server = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
server.bind(('127.0.0.1',9000))
msg,client_addr = server.recvfrom(1024) # 接收到的是内容和发送地址
server.sendto('你也好'.encode('utf-8'),client_addr) # 指定内容和发送地址
server.close()

'''客户端'''
import socket
sock = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
sock.sendto('你好'.encode('utf-8'),('127.0.0.1',9000))
msg,server_addr = sock.recvfrom(1024)
sock.close()
~~~

## **tcp协议的粘包问题**

**出现原因**：
	tcp是流式协议，数据之间没有边界
	收数据时没有收干净，有残留，就会和下一次结果混淆在一起

**解决办法**：
	获取数据的总大小
	循环接收，每接收一次累计一次

~~~python
# tcp协议粘包问题的本质就是数据之间没有边界，解决方法也就是设置一个边界，并且判断

'''服务端'''
import socket
import struct # struct模块的作用是把一个数字转换成固定长度的二进制数
server = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
server.bind(('127.0.0.1',9000))
server.listen()
conn,_ = server.accept()
while 1:
    n = 0
    try:
        msg = conn.recv(4)
        data_size = struct.unpack('i',msg)[0] # 反解，返回一个元组，第一个参数就是数字
    except Exception:break
    with open('1.txt',mode='wb') as f:
        while n < data_size:
            msg = conn.recv(1024)
            f.write(msg)
            n += len(msg)
        print('写入完成')

'''客户端'''
import socket
import struct
sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
sock.connect(('127.0.0.1',9000))
while 1:
    x = input('>>>').encode('utf-8')
    data_size = struct.pack('i',len(x)) # 打包，两个参数，第一个表示模式，第二个是打包的数字，返回一个二进制
    sock.send(data_size)
    sock.send(x)
    
    
    
~~~

![](C:\Users\Zhao\Desktop\图\struct模块参数.png)

**进阶解决方法**

~~~python
# 将所需信息封装成一个头字典
dic = {'filename':'vc.mp4','filesize':501024}
# 用json模块进行转换
dic = json.dumps(dic).encode('utf-8')
# 用struct模块打包头字典长度
bao = struct.pack('i',len(dic))
# 接收头字典
# 反解头字典
bao = bao.decode('utf-8')
bao = json.loads(bao)
# 获取文件大小，循环接收
n = 0 
with open(bao['filename'],mode='wb') as f:
    while n < bao['filesize']:
        msg = conn.recv(1024)
        f.write(msg)
        n += len(msg)
~~~

## 并发socketserver模块

~~~python
'''tcp服务端'''
import socketserver
class MyRequestHandle(socketserver.BaseRequestHandler):
    def handle(self):
        # 通信循环代码
        # 逻辑体
        conn = self.request
        client_addr = self.client_address
        pass
s = socketserver.ThreadingTCPServer(('127.0.0.1',9000),MyRequestHandle)
s.serve_forever() # 开启永久服务


'''udp服务端'''
import socketserver
class MyRequestHandle(socketserver.BaseRequestHandler):
    def handle(self):
        # 通信循环代码
        # 逻辑体
        client_data = self.request[0]
        server = self.request[1]
        client_address = self.client_address
        server.sendto()
        pass
s = socketserver.ThreadingUDPServer(('127.0.0.1',9000),MyRequestHandle)
s.serve_forever() # 开启永久服务


~~~



